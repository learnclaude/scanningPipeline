version: '3.8'

services:
  nginx:
    image: nginx:alpine
    ports:
      - "18090:80"
      - "443:443"
    volumes:
      - ./nginx/prod.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
      - nginx-cache:/var/cache/nginx
    depends_on:
      - app
    networks:
      - prod-network
    restart: always
    deploy:
      mode: replicated
      replicas: 2
      update_config:
        parallelism: 1
        delay: 10s
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost/health"]
      interval: 30s
      timeout: 3s
      retries: 3
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "5"
        labels: "service=nginx,env=production"

  prod-image-watcher:
    image: alpine:latest
    container_name: filename-generator-prod-watcher
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    environment:
      DOCKER_REGISTRY: ${DOCKER_REGISTRY:-docker.io}
      DOCKER_IMAGE: ${DOCKER_IMAGE:-filename-generator}
      PRODUCTION_TAG: ${PRODUCTION_TAG:-prod}
      STAGING_APPROVAL_WEBHOOK: ${STAGING_APPROVAL_WEBHOOK}
      PROD_DEPLOYMENT_WEBHOOK: ${PROD_DEPLOYMENT_WEBHOOK}
      SLACK_WEBHOOK: ${SLACK_WEBHOOK}
    command: |
      sh -c "
        apk add --no-cache docker-cli curl jq &&
        echo 'Starting production image watcher...' &&
        while true; do
          echo 'Checking for new prod-labeled images...' &&
          PROD_IMAGE=$$DOCKER_REGISTRY/$$DOCKER_IMAGE:$$PRODUCTION_TAG &&
          
          # Pull latest prod image
          docker pull $$PROD_IMAGE 2>/dev/null || echo 'No prod image available' &&
          
          # Get current running image ID
          CURRENT_ID=\$$(docker inspect filename-generator-prod --format='{{.Image}}' 2>/dev/null || echo 'none') &&
          LATEST_ID=\$$(docker inspect $$PROD_IMAGE --format='{{.Id}}' 2>/dev/null || echo 'none') &&
          
          if [ \"$$CURRENT_ID\" != \"$$LATEST_ID\" ] && [ \"$$LATEST_ID\" != 'none' ]; then
            echo 'New production image detected!' &&
            
            # Send notification
            if [ -n \"$$SLACK_WEBHOOK\" ]; then
              curl -X POST $$SLACK_WEBHOOK -H 'Content-Type: application/json' \
                -d '{\"text\":\"ðŸš€ New production deployment available for filename-generator\",\"attachments\":[{\"color\":\"warning\",\"fields\":[{\"title\":\"Action Required\",\"value\":\"Manual approval needed for production deployment\",\"short\":false}]}]}' || echo 'Slack notification failed'
            fi &&
            
            # Wait for manual approval (production should be manual)
            echo 'Production deployment requires manual approval...' &&
            echo 'Run: docker compose -f docker-compose.prod.yml up -d app --no-deps' &&
            
            # Optional: Send webhook for external approval system
            if [ -n \"$$PROD_DEPLOYMENT_WEBHOOK\" ]; then
              curl -X POST $$PROD_DEPLOYMENT_WEBHOOK -H 'Content-Type: application/json' \
                -d '{\"action\":\"approval_required\",\"service\":\"production\",\"image\":\"'$$PROD_IMAGE'\"}' || echo 'Approval webhook failed'
            fi
          fi &&
          
          sleep 600  # Check every 10 minutes for production
        done
      "
    networks:
      - prod-network
    restart: unless-stopped

  app:
    image: ${DOCKER_REGISTRY:-docker.io}/${DOCKER_IMAGE:-filename-generator}:${PRODUCTION_TAG:-prod}
    # No external ports - only accessible via nginx
    expose:
      - "3000"
    environment:
      NODE_ENV: production
      PORT: 3000
      NEXT_PUBLIC_API_URL: ${PRODUCTION_API_URL}
      # Production-specific environment variables
      LOG_LEVEL: ${LOG_LEVEL:-info}
      ENABLE_MONITORING: ${ENABLE_MONITORING:-true}
      SENTRY_DSN: ${SENTRY_DSN}
      SENTRY_ENVIRONMENT: production
      # Performance tuning
      NODE_OPTIONS: "--max-old-space-size=2048"
    restart: always
    networks:
      - prod-network
    deploy:
      mode: replicated
      replicas: ${REPLICAS:-2}
      update_config:
        parallelism: 1
        delay: 10s
        failure_action: rollback
        monitor: 60s
        max_failure_ratio: 0.3
      restart_policy:
        condition: any
        delay: 5s
        max_attempts: 3
        window: 120s
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '1'
          memory: 1G
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 40s
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "10"
        labels: "service=filename-generator,env=production"
    secrets:
      - source: app_secrets
        target: /run/secrets/app_secrets


  redis:
    image: redis:7-alpine
    container_name: filename-generator-redis-prod
    command: redis-server --maxmemory 256mb --maxmemory-policy allkeys-lru
    # No external ports - only accessible via internal network
    expose:
      - "6379"
    networks:
      - prod-network
    restart: always
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
    volumes:
      - redis-data:/data
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

networks:
  prod-network:
    driver: overlay
    encrypted: true
    internal: false
    attachable: true
    ipam:
      config:
        - subnet: 172.21.0.0/16

volumes:
  nginx-cache:
    driver: local
  redis-data:
    driver: local

secrets:
  app_secrets:
    external: true